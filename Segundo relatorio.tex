\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}

% Configuração de página
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Configuração de cores
\definecolor{codeblue}{RGB}{0,102,204}
\definecolor{codegray}{RGB}{128,128,128}
\definecolor{codegreen}{RGB}{0,128,0}
\definecolor{backcolour}{RGB}{245,245,245}

% Configuração de código VHDL
\lstdefinestyle{vhdlstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    language=VHDL
}
\lstset{style=vhdlstyle}

% Configuração de hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=codeblue,
    urlcolor=codeblue,
    citecolor=codeblue
}

% Cabeçalho e rodapé
\pagestyle{fancy}
\fancyhf{}
\rhead{Extensão Vetorial RISC-V}
\lhead{Arquitetura de Computadores}
\rfoot{Página \thepage}

%=============================================================================
% INÍCIO DO DOCUMENTO
%=============================================================================
\begin{document}

%=============================================================================
% CAPA
%=============================================================================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\LARGE \textbf{Universidade Federal do Rio de Janeiro}}\\[0.5cm]
    {\Large Centro de Tecnologia}\\[0.3cm]
    {\Large Escola Politécnica}\\[2cm]
    
    \rule{\linewidth}{0.5mm}\\[0.4cm]
    {\Huge \textbf{Extensão Vetorial para CPU RISC-V}}\\[0.2cm]
    {\Large RV32I + Instruções SIMD - Relatório Técnico}\\
    \rule{\linewidth}{0.5mm}\\[2cm]
    
    \textbf{Autores:}\\[0.3cm]
    Breno Valente Manhães - DRE: 122038517\\
    Thomas Cardoso de Miranda - DRE: 122050797\\
    Murilo Jorge de Figueiredo - DRE: 122079597\\
    Gabriel Brígido Pinheiro da Silva - DRE: 120056519\\
    Carlos Bruno Barbosa Correia - DRE: 122039987\\[1cm]
    
    \textit{Disciplina: EEL580 - Arquitetura de Computadores}\\
    \textit{Professor: Diego Leonel Cadete Dutra}\\[2cm]
    
    \textbf{Repositório GitHub:}\\[0.2cm]
    \url{https://github.com/brenopprufrj/Trabalho_RiscV_Digital_Basic.git}\\[2cm]
    
    \vfill
    {\large Rio de Janeiro - RJ}\\
    {\large Janeiro de 2026}
\end{titlepage}

%=============================================================================
% SUMÁRIO
%=============================================================================
\tableofcontents
\newpage

%=============================================================================
% 1. INTRODUÇÃO
%=============================================================================
\section{Introdução}

Este relatório descreve a implementação da extensão vetorial para a CPU RISC-V de 32 bits (RV32I) com arquitetura de pipeline de 5 estágios, desenvolvida em VHDL para uso no simulador Digital. A extensão adiciona suporte a operações SIMD (Single Instruction, Multiple Data) com registradores de 128 bits (4 lanes × 32 bits).

\subsection{Objetivos}

O objetivo desta tarefa é estender a CPU RISC-V de 32 bits desenvolvida anteriormente para suportar instruções vetoriais, atendendo aos seguintes requisitos:

\begin{itemize}
    \item Manter pipeline com pelo menos 5 estágios
    \item Implementar versões vetoriais das instruções: \texttt{add}, \texttt{addi}, \texttt{auipc}, \texttt{sub}
    \item Implementar versões vetoriais das instruções: \texttt{sll}, \texttt{slli}, \texttt{srl}, \texttt{srli}
    \item Manter compatibilidade com o subconjunto RV32I da tarefa anterior
    \item Codificação aderente à proposta da arquitetura RISC-V
    \item Sinais de debug para aferição de estados internos
\end{itemize}

\subsection{Instruções Vetoriais Suportadas}

A extensão implementa 8 instruções vetoriais:

\begin{itemize}
    \item \textbf{Aritméticas:} \texttt{vadd}, \texttt{vaddi}, \texttt{vauipc}, \texttt{vsub}
    \item \textbf{Deslocamento:} \texttt{vsll}, \texttt{vslli}, \texttt{vsrl}, \texttt{vsrli}
\end{itemize}

%=============================================================================
% 2. ARQUITETURA VETORIAL
%=============================================================================
\section{Arquitetura Vetorial}

\subsection{Registradores Vetoriais}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Característica} & \textbf{Especificação} \\
\hline
Quantidade & 32 registradores (\texttt{v0}-\texttt{v31}) \\
Largura & 128 bits (4 lanes × 32 bits) \\
\texttt{v0} & \textbf{Gravável} (diferente de \texttt{x0} escalar) \\
\hline
\end{tabular}
\caption{Especificação dos Registradores Vetoriais}
\end{table}

\subsection{Modelo SIMD}

Cada instrução vetorial opera em paralelo sobre 4 elementos de 32 bits, seguindo o modelo SIMD (Single Instruction, Multiple Data):

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Lane 3} & \textbf{Lane 2} & \textbf{Lane 1} & \textbf{Lane 0} \\
\textbf{bits 127:96} & \textbf{bits 95:64} & \textbf{bits 63:32} & \textbf{bits 31:0} \\
\hline
\end{tabular}
\caption{Organização do Registrador Vetorial de 128 bits}
\end{table}

Esta abordagem permite executar 4 operações de 32 bits simultaneamente em um único ciclo de clock.

%=============================================================================
% 3. ESCOLHAS DE PROJETO
%=============================================================================
\section{Escolhas de Projeto}

\subsection{Codificação de Instruções}

\subsubsection{Opcodes Utilizados}

Utilizamos os opcodes \texttt{custom-0} (\texttt{0x0B}) e \texttt{custom-1} (\texttt{0x2B}) reservados pela especificação RISC-V para extensões personalizadas:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
\textbf{Nome} & \textbf{Opcode (Bin)} & \textbf{Opcode (Hex)} & \textbf{Uso} \\
\hline
custom-0 & 0001011 & 0x0B & Instruções R-type e I-type vetoriais \\
custom-1 & 0101011 & 0x2B & VAUIPC (U-type vetorial) \\
\hline
\end{tabular}
\caption{Opcodes Vetoriais}
\end{table}

\textbf{Justificativa:}
\begin{itemize}
    \item[$\checkmark$] Mantém compatibilidade com RV32I base
    \item[$\checkmark$] Evita conflitos com instruções padrão
    \item[$\checkmark$] Permite fácil identificação no decodificador
\end{itemize}

\subsubsection{Diferenciação das Operações}

\begin{itemize}
    \item \texttt{funct7[5]} diferencia \texttt{vadd} (0) de \texttt{vsub} (1)
    \item \texttt{funct3} diferencia operações de shift das aritméticas
\end{itemize}

\subsection{Unidade Lógico-Aritmética Vetorial (VALU)}

A VALU implementa 4 ALUs paralelas, uma para cada lane. Cada ALU de 32 bits executa independentemente a mesma operação sobre seu elemento correspondente do registrador vetorial.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|l|}
\hline
\textbf{Código} & \textbf{Binário} & \textbf{Operação} \\
\hline
0 & 0000 & ADD (Soma) \\
1 & 0001 & SUB (Subtração) \\
5 & 0101 & SLL (Shift Left Logical) \\
6 & 0110 & SRL (Shift Right Logical) \\
\hline
\end{tabular}
\caption{Códigos de Controle da VALU}
\end{table}

\subsection{Forwarding Vetorial}

Para evitar hazards de dados nas operações vetoriais, implementamos uma \textbf{Vector Forwarding Unit} dedicada que opera em paralelo com o forwarding escalar:

\begin{lstlisting}[caption={Seleção de Forwarding Vetorial}]
-- Fontes de forwarding vetorial
vec_fwd_a_sel: "00" = registrador, "01" = MEM, "10" = WB
vec_fwd_b_sel: "00" = registrador, "01" = MEM, "10" = WB
\end{lstlisting}

O forwarding vetorial detecta dependências entre instruções vetoriais consecutivas e encaminha os dados dos estágios MEM e WB para evitar stalls desnecessários.

\subsection{Read-During-Write no Banco de Registradores}

O banco de registradores vetoriais implementa \textbf{forwarding interno} para resolver conflitos de leitura durante escrita no mesmo ciclo:

\begin{lstlisting}[caption={Forwarding Interno no Banco de Registradores}]
-- Se lendo e escrevendo no mesmo registrador simultaneamente,
-- retorna o valor sendo escrito (data_i) em vez do armazenado
if (rd1_addr_i = wd_addr_i and we_i = '1') then
    rd1_data_o <= data_i;  -- Forward do dado sendo escrito
else
    rd1_data_o <= regs(to_integer(unsigned(rd1_addr_i)));
end if;
\end{lstlisting}

Esta escolha elimina bolhas de pipeline quando uma instrução lê um registrador que está sendo escrito no mesmo ciclo.

\subsection{Registradores de Pipeline Vetoriais}

Adicionamos registradores de pipeline dedicados para dados vetoriais:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Registrador} & \textbf{Dados Armazenados} \\
\hline
ID/EX & vs1\_data (128), vs2\_data (128), is\_vector \\
EX/MEM & valu\_result (128), vd\_addr, v\_reg\_write \\
MEM/WB & valu\_result (128), vd\_addr, v\_reg\_write \\
\hline
\end{tabular}
\caption{Registradores de Pipeline Vetoriais}
\end{table}

%=============================================================================
% 4. DIAGRAMA DA ARQUITETURA
%=============================================================================
\section{Diagrama da Arquitetura}

A Figura \ref{fig:arch_vector} apresenta o diagrama da CPU com extensão vetorial:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7, every node/.style={scale=0.7}]
    % Pipeline stages
    \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=blue!10] (IF) at (0,0) {IF};
    \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=green!10] (ID) at (2.5,0) {ID};
    \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=orange!10] (EX) at (5,0) {EX};
    \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=red!10] (MEM) at (7.5,0) {MEM};
    \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=purple!10] (WB) at (10,0) {WB};
    
    % Pipeline registers
    \node[draw, fill=gray!20, minimum width=0.5cm, minimum height=1.2cm] (IFID) at (1.25,0) {\rotatebox{90}{\tiny IF/ID}};
    \node[draw, fill=gray!20, minimum width=0.5cm, minimum height=1.2cm] (IDEX) at (3.75,0) {\rotatebox{90}{\tiny ID/EX}};
    \node[draw, fill=gray!20, minimum width=0.5cm, minimum height=1.2cm] (EXMEM) at (6.25,0) {\rotatebox{90}{\tiny EX/MEM}};
    \node[draw, fill=gray!20, minimum width=0.5cm, minimum height=1.2cm] (MEMWB) at (8.75,0) {\rotatebox{90}{\tiny MEM/WB}};
    
    % Scalar components
    \node[draw, fill=blue!20, minimum width=1.5cm] (PC) at (0,-2) {\tiny PC};
    \node[draw, fill=blue!20, minimum width=1.5cm] (IMEM) at (0,-3.5) {\tiny IMEM};
    \node[draw, fill=green!20, minimum width=1.5cm] (DEC) at (2.5,-2) {\tiny Decoder};
    \node[draw, fill=green!20, minimum width=1.5cm] (REG) at (2.5,-3.5) {\tiny RegFile};
    \node[draw, fill=orange!20, minimum width=1.5cm] (ALU) at (5,-2.5) {\tiny ALU};
    \node[draw, fill=red!20, minimum width=1.5cm] (DMEM) at (7.5,-2.5) {\tiny DMEM};
    
    % Vector components (highlighted)
    \node[draw, fill=cyan!30, minimum width=1.5cm, line width=1pt] (VREG) at (2.5,-5) {\tiny VRegFile};
    \node[draw, fill=cyan!30, minimum width=1.5cm, line width=1pt] (VALU) at (5,-5) {\tiny VALU};
    
    % Labels for vector
    \node at (2.5,-6) {\tiny (v0-v31)};
    \node at (5,-6) {\tiny (4 lanes)};
    
    % Hazard/Forwarding
    \node[draw, fill=yellow!30, minimum width=6cm, minimum height=0.5cm] (HF) at (5,-7.5) {\tiny Hazard Unit + Forwarding (Escalar + Vetorial)};
    
    % Connections
    \draw[->] (IF) -- (IFID);
    \draw[->] (IFID) -- (ID);
    \draw[->] (ID) -- (IDEX);
    \draw[->] (IDEX) -- (EX);
    \draw[->] (EX) -- (EXMEM);
    \draw[->] (EXMEM) -- (MEM);
    \draw[->] (MEM) -- (MEMWB);
    \draw[->] (MEMWB) -- (WB);
    
    % Writeback path
    \draw[->, dashed] (WB.south) -- (10,-4) -- (2.5,-4) -- (REG.east);
    \draw[->, dashed, cyan] (10,-4.5) -- (2.5,-4.5) -- (VREG.east);
\end{tikzpicture}
\caption{Arquitetura RISC-V com Extensão Vetorial}
\label{fig:arch_vector}
\end{figure}

%=============================================================================
% 5. ESTRUTURA DE ARQUIVOS
%=============================================================================
\section{Estrutura de Arquivos}

\subsection{Módulos Vetoriais (Novos)}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Arquivo} & \textbf{Descrição} \\
\hline
\texttt{vector\_alu.vhd} & ALU vetorial (4 lanes paralelas) \\
\texttt{vector\_register\_file.vhd} & Banco de 32 registradores vetoriais (128 bits) \\
\texttt{vector\_forwarding\_unit.vhd} & Forwarding para operandos vetoriais \\
\texttt{vector\_pipeline\_regs.vhd} & Registradores de pipeline vetoriais \\
\texttt{riscv\_cpu\_vector.vhd} & Top-level com extensão vetorial \\
\hline
\end{tabular}
\caption{Novos Módulos Vetoriais}
\end{table}

\subsection{Módulos Modificados}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Arquivo} & \textbf{Modificações} \\
\hline
\texttt{instruction\_decoder.vhd} & Decodificação de opcodes \texttt{custom-0/1} \\
\texttt{control\_unit.vhd} & Sinais de controle vetoriais \\
\texttt{hazard\_unit.vhd} & Detecção de hazards vetoriais \\
\hline
\end{tabular}
\caption{Módulos Modificados para Suporte Vetorial}
\end{table}

%=============================================================================
% 6. INTERFACE DE DEBUG
%=============================================================================
\section{Interface de Debug Vetorial}

Para aferição de estados internos, conforme requisitado, foram adicionados sinais de debug específicos para a extensão vetorial:

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|}
\hline
\textbf{Sinal} & \textbf{Bits} & \textbf{Descrição} \\
\hline
\texttt{vreg\_sel\_i} & 5 & Seleção do registrador vetorial (entrada) \\
\texttt{vreg\_debug\_lane0\_o} & 32 & Lane 0 (bits 31:0) do vreg selecionado \\
\texttt{vreg\_debug\_lane1\_o} & 32 & Lane 1 (bits 63:32) do vreg selecionado \\
\texttt{vreg\_debug\_lane2\_o} & 32 & Lane 2 (bits 95:64) do vreg selecionado \\
\texttt{vreg\_debug\_lane3\_o} & 32 & Lane 3 (bits 127:96) do vreg selecionado \\
\texttt{valu\_result\_lane*\_o} & 32 & Resultado da VALU por lane \\
\hline
\end{tabular}
\caption{Sinais de Debug Vetorial}
\end{table}

\textbf{Nota:} As saídas estão divididas em 4 lanes de 32 bits devido à limitação de 64 bits do Splitter do simulador Digital.

%=============================================================================
% 7. CONCLUSÃO
%=============================================================================
\section{Conclusão}

A extensão vetorial implementada atende a todos os requisitos da Tarefa 2:

\begin{itemize}
    \item[$\checkmark$] Suporte a versões vetoriais de \texttt{add}, \texttt{addi}, \texttt{auipc}, \texttt{sub}
    \item[$\checkmark$] Suporte a versões vetoriais de \texttt{sll}, \texttt{slli}, \texttt{srl}, \texttt{srli}
    \item[$\checkmark$] Mantém pipeline de 5 estágios
    \item[$\checkmark$] Compatível com subconjunto RV32I existente
    \item[$\checkmark$] Codificação aderente à proposta RISC-V (opcodes \texttt{custom-0/1})
    \item[$\checkmark$] Sinais de debug para aferição de estados internos vetoriais
\end{itemize}

O projeto demonstra a viabilidade de estender uma CPU RISC-V de pipeline para suportar operações SIMD, mantendo a compatibilidade com o conjunto de instruções base e seguindo as convenções de codificação da arquitetura.

%=============================================================================
% REFERÊNCIAS
%=============================================================================
\section*{Referências}
\addcontentsline{toc}{section}{Referências}

\begin{enumerate}
    \item RISC-V Foundation. \textit{The RISC-V Instruction Set Manual, Volume I: User-Level ISA}. Disponível em: \url{https://riscv.org/specifications/}
    \item RISC-V Foundation. \textit{RISC-V "V" Vector Extension, Version 1.0}. Disponível em: \url{https://github.com/riscv/riscv-v-spec}
    \item Neemann, H. \textit{Digital - A digital logic designer and circuit simulator}. Disponível em: \url{https://github.com/hneemann/Digital}
    \item GHDL. \textit{GHDL - Open-source VHDL simulator}. Disponível em: \url{https://github.com/ghdl/ghdl}
    \item Patterson, D. A.; Hennessy, J. L. \textit{Computer Organization and Design: The Hardware/Software Interface}. Morgan Kaufmann, 2020.
\end{enumerate}

%=============================================================================
% APÊNDICE A: REFERÊNCIA DE INSTRUÇÕES VETORIAIS
%=============================================================================
\newpage
\appendix
\section{Referência de Instruções Vetoriais}
\label{apendice:instrucoes_vetoriais}

Esta seção apresenta a documentação completa de opcodes e instruções vetoriais suportadas pela extensão vetorial da CPU RISC-V.

\textbf{Nota:} A referência completa das instruções escalares RV32I encontra-se no Apêndice A do relatório anterior (Primeiro Relatório).

\subsection{Opcodes Vetoriais}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
\textbf{Nome} & \textbf{Opcode (Bin)} & \textbf{Opcode (Hex)} & \textbf{Uso} \\
\hline
custom-0 & 0001011 & 0x0B & Instruções vetoriais R-type e I-type \\
custom-1 & 0101011 & 0x2B & VAUIPC (U-type) \\
\hline
\end{tabular}
\caption{Tabela de Opcodes Vetoriais}
\label{tab:opcodes_vec}
\end{table}

\subsection{Instruções R-type Vetoriais}

Formato: \texttt{funct7[6:0] | rs2[4:0] | rs1[4:0] | funct3[2:0] | rd[4:0] | opcode[6:0]}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{Instrução} & \textbf{funct7} & \textbf{funct3} & \textbf{Opcode} & \textbf{Operação} \\
\hline
vadd vd, vs1, vs2 & 0000000 & 000 & 0001011 & vd[i] = vs1[i] + vs2[i] \\
vsub vd, vs1, vs2 & 0100000 & 000 & 0001011 & vd[i] = vs1[i] - vs2[i] \\
vsll vd, vs1, vs2 & 0000000 & 001 & 0001011 & vd[i] = vs1[i] $\ll$ vs2[i][4:0] \\
vsrl vd, vs1, vs2 & 0000000 & 101 & 0001011 & vd[i] = vs1[i] $\gg$ vs2[i][4:0] \\
\hline
\end{tabular}
\caption{Instruções Vetoriais R-type}
\label{tab:vec_rtype}
\end{table}

\subsection{Instruções I-type Vetoriais}

Formato: \texttt{imm[11:0] | rs1[4:0] | funct3[2:0] | rd[4:0] | opcode[6:0]}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Instrução} & \textbf{funct3} & \textbf{Opcode} & \textbf{Operação} \\
\hline
vaddi vd, vs1, imm & 010 & 0001011 & vd[i] = vs1[i] + imm \\
vslli vd, vs1, shamt & 011 & 0001011 & vd[i] = vs1[i] $\ll$ shamt \\
vsrli vd, vs1, shamt & 111 & 0001011 & vd[i] = vs1[i] $\gg$ shamt \\
\hline
\end{tabular}
\caption{Instruções Vetoriais I-type}
\label{tab:vec_itype}
\end{table}

\textbf{Nota:} Para \texttt{vslli} e \texttt{vsrli}, o imediato usa apenas os 5 bits menos significativos (shamt).

\subsection{Instrução VAUIPC (U-type)}

Formato: \texttt{imm[31:12] | rd[4:0] | opcode[6:0]}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|}
\hline
\textbf{Instrução} & \textbf{Opcode} & \textbf{Operação} \\
\hline
vauipc vd, imm & 0101011 & vd[i] = PC + (imm $\ll$ 12) \\
\hline
\end{tabular}
\caption{Instrução VAUIPC}
\label{tab:vauipc}
\end{table}

\subsection{Códigos de Controle da VALU}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|l|l|}
\hline
\textbf{Nome} & \textbf{Código} & \textbf{Operação} & \textbf{Descrição} \\
\hline
VALU\_ADD & 0000 & A + B & Soma vetorial \\
VALU\_SUB & 0001 & A - B & Subtração vetorial \\
VALU\_SLL & 0101 & A $\ll$ B[4:0] & Shift left logical \\
VALU\_SRL & 0110 & A $\gg$ B[4:0] & Shift right logical \\
\hline
\end{tabular}
\caption{Códigos de Controle da VALU}
\label{tab:valu_ctrl}
\end{table}

\subsection{Exemplos de Codificação}

\textbf{Exemplo 1: \texttt{vaddi v1, v0, 5}} -- Carrega o valor 5 em todas as lanes de v1.
\begin{verbatim}
imm[11:0]    = 000000000101 (5)
rs1[4:0]     = 00000 (v0)
funct3[2:0]  = 010
rd[4:0]      = 00001 (v1)
opcode[6:0]  = 0001011

Binário: 0000 0000 0101 0000 0010 0000 1000 1011
Hex:     0x0050208B
\end{verbatim}

\textbf{Exemplo 2: \texttt{vadd v3, v1, v2}} -- Soma vetorial de v1 + v2 em v3.
\begin{verbatim}
funct7[6:0]  = 0000000
rs2[4:0]     = 00010 (v2)
rs1[4:0]     = 00001 (v1)
funct3[2:0]  = 000
rd[4:0]      = 00011 (v3)
opcode[6:0]  = 0001011

Binário: 0000 0000 0010 0000 1000 0001 1000 1011
Hex:     0x0020818B
\end{verbatim}

\textbf{Exemplo 3: \texttt{vsub v4, v1, v2}} -- Subtração vetorial de v1 - v2 em v4.
\begin{verbatim}
funct7[6:0]  = 0100000
rs2[4:0]     = 00010 (v2)
rs1[4:0]     = 00001 (v1)
funct3[2:0]  = 000
rd[4:0]      = 00100 (v4)
opcode[6:0]  = 0001011

Binário: 0100 0000 0010 0000 1000 0010 0000 1011
Hex:     0x4020820B
\end{verbatim}

\textbf{Exemplo 4: \texttt{vslli v5, v1, 2}} -- Shift left de 2 bits em todas as lanes.
\begin{verbatim}
imm[11:0]    = 000000000010 (2)
rs1[4:0]     = 00001 (v1)
funct3[2:0]  = 011
rd[4:0]      = 00101 (v5)
opcode[6:0]  = 0001011

Hex:     0x0020B28B
\end{verbatim}

\subsection{Programa de Exemplo}

\begin{lstlisting}[caption={Programa Assembly Vetorial}]
vaddi v1, v0, 5    # v1 = [5, 5, 5, 5]
vaddi v2, v0, 3    # v2 = [3, 3, 3, 3]
vadd  v3, v1, v2   # v3 = [8, 8, 8, 8]
vsub  v4, v1, v2   # v4 = [2, 2, 2, 2]
vslli v5, v1, 2    # v5 = [20, 20, 20, 20]
nop
\end{lstlisting}

Código hexadecimal para ROM:
\begin{verbatim}
50208b,30210b,20818b,4020820b,20b28b,13
\end{verbatim}

\end{document}
